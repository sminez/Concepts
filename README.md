# Concepts
### LISP and Haskell inspired functional programming concepts for Python

Originally this was called **fmap** and was only an implementation of the `fmap` function for Python3. Now that I've been tinkering around some more I thought it'd be nice to collect a few things together. (For about a day it was then called `PythFun` but then I saw the error of my ways...)

- [fmap](docs/fmap_README.md): apply a function to all elements of a collection style object.
- [pattern_match](docs/pattern_match_README.md): A hybrid of Haskell's pattern matching and Clojure's destructuring.
- [dispatch](dispatch.py): single and multiple dispatch for your Python functions.
- [prelude](prelude.py): a collection of functional programming functions.

Any suggestions for improvements are welcome and if you'd like to hack away and submit a pull request for a feature then raise an issue and let me know!

I hope you enjoy!


### Some examples...
```python
def fibgen():
    '''Because EVERYONE needs a list of Fibonacci numbers...'''
    yield 1
    yield from iscanl(fibgen(), add, 2)

>>> take(20, fibgen())
[1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946]


@tcall
def fact(n, acc=1):
    '''And compute some factorials...'''
    if n == 0:
        return acc
    else:
        return fact, (n-1, acc*n)

>>> fact(99)
933262154439441526816992388562667004907159682643816214685929638952175999932299156089414639761565182862536979208272237582511852109168640000000000000000000000

>>> fact(999)
402387260077093773543702433923003985719374864210714632543799910429938512398629020592044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759918823627727188732519779505950995276120874975462497043601418278094646496291056393887437886487337119181045825783647849977012476632889835955735432513185323958463075557409114262417474349347553428646576611667797396668820291207379143853719588249808126867838374559731746136085379534524221586593201928090878297308431392844403281231558611036976801357304216168747609675871348312025478589320767169132448426236131412508780208000261683151027341827977704784635868170164365024153691398281264810213092761244896359928705114964975419909342221566832572080821333186116811553615836546984046708975602900950537616475847728421889679646244945160765353408198901385442487984959953319101723355556602139450399736280750137837615307127761926849034352625200015888535147331611702103968175921510907788019393178114194545257223865541461062892187960223838971476088506276862967146674697562911234082439208160153780889893964518263243671616762179168909779911903754031274622289988005195444414282012187361745992642956581746628302955570299024324153181617210465832036786906117260158783520751516284225540265170483304226143974286933061690897968482590125458327168226458066526769958652682272807075781391858178889652208164348344825993266043367660176999612831860788386150279465955131156552036093988180612138558600301435694527224206344631797460594682573103790084024432438465657245014402821885252470935190620929023136493273497565513958720559654228749774011413346962715422845862377387538230483865688976461927383814900140767310446640259899490222221765904339901886018566526485061799702356193897017860040811889729918311021171229845901641921068884387121855646124960798722908519296819372388642614839657382291123125024186649353143970137428531926649875337218940694281434118520158014123344828015051399694290153483077644569099073152433278288269864602789864321139083506217095002597389863554277196742822248757586765752344220207573630569498825087968928162753848863396909959826280956121450994871701244516461260379029309120889086942028510640182154399457156805941872748998094254742173582401063677404595741785160829230135358081840096996372524230560855903700624271243416909004153690105933983835777939410970027753472000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000


>>> import sys

>>> sys.getrecursionlimit()
2000

>>> fact(9999)
284625968091705451890641321211986889014805140170279923079417999427...
# This one is 35656 digits long...


# From prelude.py
def cmap(func, col):
    '''
    Concat-Map: map a function that takes a value and returns a list over an
    iterable and concatenate the results
    '''
    return foldl(map(func, col))


def flatten(col):
    '''
    Flatten an arbitrarily nested list of lists into a single list.
    '''
    if not iscollection(col):
        return [col]
    else:
        return cmap(flatten, col)


>>> l = [1,2,[3,4,[5,6,7],[8,9]],[10,11,12],13]

>>> flatten(l)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]
```

#### NOTE:
At the moment, there are no tests for this code and it has only been run on linux under cPython 3.5. (I really should fix that...)
